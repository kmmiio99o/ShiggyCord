name: Automatic Release

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install
        shell: bash

      - name: Extract version
        id: extract
        run: |
          # Extract major.minor.patch version from scripts/build.mjs
          # This locates the first quoted three-segment version string in the build script (e.g. "1.1.7")
          if [ ! -f scripts/build.mjs ]; then
            echo "scripts/build.mjs not found" >&2
            exit 1
          fi
          # Print a snippet of the file for debugging in workflow logs
          echo '--- scripts/build.mjs (snippet) ---' >&2
          sed -n '1,200p' scripts/build.mjs >&2 || true

          # Primary extraction: find the first quoted semver (may include prerelease suffix, but we strip it)
          raw=$(grep -m1 -oE '\"[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z.-]+)?\"' scripts/build.mjs | tr -d '\"' | head -n1 || true)

          # Strip any prerelease suffix, keep only major.minor.patch
          version=$(printf '%s' "$raw" | sed -E 's/^([0-9]+\.[0-9]+\.[0-9]+).*/\1/')

          # Validate final result is exactly major.minor.patch
          if ! printf '%s' "$version" | grep -xE '^[0-9]+\.[0-9]+\.[0-9]+$' >/dev/null; then
            echo "Failed to extract a valid base version from scripts/build.mjs" >&2
            sed -n '1,200p' scripts/build.mjs >&2 || true
            exit 1
          fi

          echo "version=$version" >> $GITHUB_OUTPUT
        shell: bash

      - name: Prepare tag
        id: prepare
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Use the extracted version directly as the tag for main branch releases
          version="${{ steps.extract.outputs.version }}"
          tag="${version}"

          echo "[debug] computed tag=${tag}" >&2

          # Expose outputs
          echo "tag=${tag}" >> $GITHUB_OUTPUT

          # Ensure a committer identity is configured for tagging (CI runners don't have one by default)
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config user.name "${GITHUB_ACTOR}"

          # Create annotated tag locally and push it if not already present on the remote.
          if ! git rev-parse -q --verify "refs/tags/${tag}" >/dev/null; then
            git tag -a "${tag}" -m "Release ${tag}"
            # push tag via token-authenticated remote so workflow can push tags
            git push "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git" "refs/tags/${tag}"
          else
            echo "Tag ${tag} already exists"
          fi
        shell: bash

      - name: Build
        run: bun run build
        shell: bash

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.prepare.outputs.tag }}
          name: Release ${{ steps.prepare.outputs.tag }}
          files: |
            dist/shiggycord.js
            dist/shiggycord.min.js
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

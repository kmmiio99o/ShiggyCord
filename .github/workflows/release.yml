name: Automatic Release

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      release_name:
        description: 'Custom Release Name (e.g., "Jolly", "Christmas")'
        required: true
        type: string
      release_tag:
        description: 'Release Tag (e.g., "v1.0.0")'
        required: true
        type: string

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install
        shell: bash

      - name: Determine Release Info
        id: release_info
        run: |
          # For workflow_dispatch, use the provided inputs
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            release_name="${{ github.event.inputs.release_name }}"
            release_tag="${{ github.event.inputs.release_tag }}"
          else
            # For push events, extract version and generate a name
            if [ ! -f scripts/build.mjs ]; then
              echo "scripts/build.mjs not found" >&2
              exit 1
            fi

            # Extract version
            raw=$(grep -m1 -oE '\"[0-9]+\.[0-9]+\.[0-9]+(-[0-9A-Za-z.-]+)?\"' scripts/build.mjs | tr -d '\"' | head -n1 || true)
            version=$(printf '%s' "$raw" | sed -E 's/^([0-9]+\.[0-9]+\.[0-9]+).*/\1/')

            if ! printf '%s' "$version" | grep -xE '^[0-9]+\.[0-9]+\.[0-9]+$' >/dev/null; then
              echo "Failed to extract a valid base version from scripts/build.mjs" >&2
              exit 1
            fi

            # Use version-based naming for push events
            release_name="Release v${version}"
            release_tag="v${version}"
          fi

          echo "release_name=${release_name}" >> $GITHUB_OUTPUT
          echo "release_tag=${release_tag}" >> $GITHUB_OUTPUT
          echo "Using release name: ${release_name}" >&2
          echo "Using release tag: ${release_tag}" >&2
        shell: bash

      - name: Prepare tag
        id: prepare
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          tag="${{ steps.release_info.outputs.release_tag }}"

          echo "[debug] computed tag=${tag}" >&2

          # Expose outputs
          echo "tag=${tag}" >> $GITHUB_OUTPUT

          # Ensure a committer identity is configured for tagging (CI runners don't have one by default)
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git config user.name "${GITHUB_ACTOR}"

          # Create annotated tag locally and push it if not already present on the remote.
          if ! git rev-parse -q --verify "refs/tags/${tag}" >/dev/null; then
            git tag -a "${tag}" -m "Release ${tag}"
            # push tag via token-authenticated remote so workflow can push tags
            git push "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git" "refs/tags/${tag}"
          else
            echo "Tag ${tag} already exists"
          fi
        shell: bash

      - name: Build
        run: bun run build
        shell: bash

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.release_info.outputs.release_tag }}
          name: ${{ steps.release_info.outputs.release_name }}
          files: |
            dist/shiggycord.js
            dist/shiggycord.min.js
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
